- name: "{{ app.namespace }} - Get deployments"
  command: kubectl get deployments -n {{ app.namespace }} -o json --kubeconfig {{ kubeconfig_path }}
  register: deployments_raw
  changed_when: false

- name: Parse deployments
  set_fact:
    deployments: "{{ deployments_raw.stdout | from_json | json_query('items') }}"

- name: "{{ app.namespace }} - Scale down deployments"
  command: kubectl scale deployment {{ item.metadata.name }} -n {{ app.namespace }} --replicas=0 --kubeconfig {{ kubeconfig_path }}
  loop: "{{ deployments }}"
  loop_control:
    label: "{{ item.metadata.name }}"

- name: "{{ app.namespace }} - Wait for pods to terminate"
  command: kubectl wait --for=delete pod -l app.kubernetes.io/name={{ app.namespace }} -n {{ app.namespace }} --timeout=120s --kubeconfig {{ kubeconfig_path }}
  ignore_errors: true

- name: Display PVCs
  debug:
    msg: "{{ app }}"

- name: "{{ app.namespace }} - Clear PVCs"
  vars:
    pod_spec:
      spec:
        containers:
          - name: cleanup
            image: busybox
            command: ["sh", "-c", "rm -rf /data/* /data/.* 2>/dev/null; echo done"]
            volumeMounts:
              - name: data
                mountPath: /data
        volumes:
          - name: data
            persistentVolumeClaim:
              claimName: "{{ item }}"
  command: >
    kubectl run cleanup-{{ item }} -n {{ app.namespace }}
    --image=busybox
    --restart=Never
    --overrides='{{ pod_spec | to_json }}'
    --kubeconfig {{ kubeconfig_path }}
  loop: "{{ app.pvcs }}"

- name: "{{ app.namespace }} - Wait for cleanup pods"
  command: kubectl wait --for=jsonpath='{.status.phase}'=Succeeded pod/cleanup-{{ item }} -n {{ app.namespace }} --timeout=120s --kubeconfig {{ kubeconfig_path }}
  loop: "{{ app.pvcs }}"
  ignore_errors: true

- name: "{{ app.namespace }} - Delete cleanup pods"
  command: kubectl delete pod cleanup-{{ item }} -n {{ app.namespace }} --kubeconfig {{ kubeconfig_path }}
  loop: "{{ app.pvcs }}"
  ignore_errors: true

- name: "{{ app.namespace }} - Create restore"
  command: >
    kubectl apply -f - --kubeconfig {{ kubeconfig_path }}
  args:
    stdin: |
      apiVersion: k8up.io/v1
      kind: Restore
      metadata:
        name: restore-{{ lookup('pipe', 'date +%s') }}
        namespace: {{ app.namespace }}
      spec:
        backend: {{ app.backend | to_json }}
        restoreMethod:
          folder:
            claimName: {{ item }}
  loop: "{{ app.pvcs }}"
  when: app.pvcs | length > 0

- name: "{{ app.namespace }} - Wait for restore job"
  shell: |
    kubectl get jobs -n {{ app.namespace }} -l k8up.io/type=restore -o json --kubeconfig {{ kubeconfig_path }} | \
    jq -e '.items[] | select(.status.succeeded == 1)' > /dev/null
  register: restore_job
  until: restore_job.rc == 0
  retries: 60
  delay: 10

- name: "{{ app.namespace }} - Wait for filesystem sync"
  pause:
    seconds: 30

- name: "{{ app.namespace }} - Scale up deployments"
  command: kubectl scale deployment {{ item.metadata.name }} -n {{ app.namespace }} --replicas={{ item.spec.replicas | default(1) }} --kubeconfig {{ kubeconfig_path }}
  loop: "{{ deployments }}"
  loop_control:
    label: "{{ item.metadata.name }}"
